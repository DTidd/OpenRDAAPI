#include <cstdio>
#include <mix.hpp>

static void SCRIPT_Xpert_Evaluate_ReadMe()
{
	FILE *fp=NULL;
	char *temp=NULL;

	temp=Rmalloc(RDAstrlen(CURRENTDIRECTORY)+RDAstrlen("Xpert.Evaluate.ReadMe")+15);
#ifdef WIN32
	sprintf(temp,"%s\\rda\\Xpert.Evaluate.ReadMe",CURRENTDIRECTORY);
#endif
#ifndef WIN32
	sprintf(temp,"%s/rda/Xpert.Evaluate.ReadMe",CURRENTDIRECTORY);
#endif
	unlink(temp);
	fp=fopen(temp,"w+b");
	if(temp!=NULL) Rfree(temp);

	fprintf(fp,"			XPERT EXPRESSION RESOURCE CONVENTIONS\n");
	fprintf(fp,"I. VALUES (Constant and Variable)\n");
	fprintf(fp,"   A. Constants\n");
	fprintf(fp,"      1. Strings\n");
	fprintf(fp,"	 Example: \"This is a string constant.\"\n");
	fprintf(fp,"      2. Numbers\n");
	fprintf(fp,"	 Examples: 10  99.4  1.541\n");
	fprintf(fp,"   B. Fields From Standard Files\n");
	fprintf(fp,"      1. [<module name>][<file name>][<field name>]\n");
	fprintf(fp,"	 Example: [FINMGT][FINYEAR][FISCAL YEAR]\n");
	fprintf(fp,"      2. [A][B][C][<occurence of file>,<start>,<length>]\n");
	fprintf(fp,"	 where A = <module name>, B = <file name>, and C = <field name>.\n");
	fprintf(fp,"	 Note: This type applies to string variables only.\n");
	fprintf(fp,"	 <occurence of file> is used in case there is more than one copy of\n");
	fprintf(fp,"	 the file being used.  It lets the program know which one to use.\n");
	fprintf(fp,"	 <start> refers to what position in the string to start with.  1\n");
	fprintf(fp,"	 represents the first position in any string.  Any part of the string \n");
	fprintf(fp,"	 to the left of <start> will not be part of the evaluated string.\n");
	fprintf(fp,"	 <length> indicates the length of the string to use starting at the\n");
	fprintf(fp,"	 <start> position of the field.\n");
	fprintf(fp,"	 Example: [FINMGT][FINEACT][ENTRY DATE][1,4,5]\n");
	fprintf(fp,"		  If the entry date is \"01-14-95\" then the evaluation of the\n");
	fprintf(fp,"		  above example would yield the string value \"14-95\".\n");
	fprintf(fp,"	 \n");
	fprintf(fp,"   C. Virtuals / Globals / Sort File Fields\n");
	fprintf(fp,"      Note: Globals are fields that are hard-coded in the program.\n");
	fprintf(fp,"      1. [<field name>]\n");
	fprintf(fp,"	<field name> refers to the name of the virtual field, global field, \n");
	fprintf(fp,"	or sort file field.\n");
	fprintf(fp,"	Example: [ORGANIZATION NAME]\n");
	fprintf(fp,"   D. Special Fields \n");
	fprintf(fp,"      Note: These are special fields hard coded within specific processes,\n");
	fprintf(fp,"            for example, paysel and paynet.\n");
	fprintf(fp,"      1. [<structure name>][<structure part name>]\n");
	fprintf(fp,"         <structure name> comes from a structure in a program. \n");
	fprintf(fp,"         <struture part name> is the name of a part of that structure.\n");
	fprintf(fp,"         Example: [SALARY][GROSS] where SALARY is the name of a structure\n");
	fprintf(fp,"         and GROSS is the name of a part in that structure.\n");
	fprintf(fp,"      2. [<structure name>][<structure part name>][<start>,<length>]\n");
	fprintf(fp,"	 The first two parts are the same as above, except that\n");
	fprintf(fp,"         <structure part name> must have a string value.\n");
	fprintf(fp,"	 <start> refers to what position in the string to start with.  1\n");
	fprintf(fp,"	 represents the first position in any string.  Any part of the string \n");
	fprintf(fp,"	 to the left of <start> will not be part of the evaluated string.\n");
	fprintf(fp,"	 <length> indicates the length of the string to use starting at the\n");
	fprintf(fp,"	 <start> position of the field.\n");
	fprintf(fp,"	 Example: [A STRUCTURE][A STRING VALUE FIELD][4,7]\n");
	fprintf(fp,"                  If [A STRUCTURE][A STRING VALUE FIELD] = \"Hello, World\"\n");
	fprintf(fp,"                  then the above example yields the value \"lo, Wor\".\n");
	fprintf(fp,"II. OPERATORS\n");
	fprintf(fp,"    Terminology: If OP is a (binary) operator, then in the expression,\n");
	fprintf(fp,"                 A OP B, A and B are called operands. (Binary operator\n");
	fprintf(fp,"                 refers to an operator that takes two operands.  A\n");
	fprintf(fp,"                 unary operator takes one operand).\n");
	fprintf(fp,"    Note: Spaces are not required between operands and operators.\n");
	fprintf(fp,"          However, spaces are allowed and are used below for readability.\n");
	fprintf(fp,"      Operator  Operation       Use \n");
	fprintf(fp,"      -------   ---------       ---\n");
	fprintf(fp,"    1.   +	Addition	A + B  where A and B have number values\n");
	fprintf(fp,"    		Append		A + B  where A and B have string values\n");
	fprintf(fp,"	Example of Append:  \"John\" + \" Doe\" = \"John Doe\". \n");
	fprintf(fp,"          \n");
	fprintf(fp,"    2.   -      Subtraction     A - B  where A and B have number values\n");
	fprintf(fp,"                Negation        -A  where A has a number value\n");
	fprintf(fp,"    3.   *      Multiplication  A * B  where A and B have number values\n");
	fprintf(fp,"    4.   /      Division        A / B  where A and B have number values\n");
	fprintf(fp,"                                       and B is not equal to 0\n");
	fprintf(fp,"    5a.  (      Left Enclosure   (<expression>) \n");
	fprintf(fp,"     b.  )      Right Enclosure  (<expression>) \n");
	fprintf(fp,"        Note: Not really operators, but put in this category. They are \n");
	fprintf(fp,"              used for precendence and readability.  For a precendence\n");
	fprintf(fp,"              example, 7 + 8 * 9 would be evaluated as  7 + (8 * 9).\n");
	fprintf(fp,"              If you wish an evaluation of (7 + 8) * 9, then the\n");
	fprintf(fp,"              expression must appear that way.  An expression with \"(\"\n");
	fprintf(fp,"              must always have \")\" in that order. \n");
	fprintf(fp,"    6. Operators: =, <, >, <=, >=, and <>  \n");
	fprintf(fp,"       Operations: equals, less than, greater than, less than or equal,\n");
	fprintf(fp,"                   greater than or equal, and not equal, respectively.\n");
	fprintf(fp,"       Uses: For all OP in {<, >, <=, >=, <>} then  A OP B is valid if \n");
	fprintf(fp,"             A and B both have number values or both have string values.\n");
	fprintf(fp,"             If A and B are strings, then these operators yield values\n");
	fprintf(fp,"             indicating whether the lexigraphical comparison of the two\n");
	fprintf(fp,"             strings is TRUE or FALSE.\n");
	fprintf(fp,"               \n");
	fprintf(fp,"       Note: The above operators are called relations or predicates.\n");
	fprintf(fp,"             The evaluation of predicate operations yield BOOLEAN\n");
	fprintf(fp,"             values, i.e., either TRUE or FALSE (1 or 0). \n");
	fprintf(fp,"      Operator  Operation       Use \n");
	fprintf(fp,"      -------   ---------       ---\n");
	fprintf(fp,"    7a.   C      Contains  	A C B  where A and B have string values\n");
	fprintf(fp,"     b.   NC     Not Contains  	A NC B  where A and B have string values\n");
	fprintf(fp,"	Note: C and NC are BOOLEAN operators, i.e., the operations yield\n");
	fprintf(fp,"              either a TRUE or FALSE value (1 or 0).  They are defined\n");
	fprintf(fp,"              as follows for all strings A and B:\n");
	fprintf(fp,"              A C B =  if B is a substring of A then\n");
	fprintf(fp,"                           TRUE\n");
	fprintf(fp,"                       else\n");
	fprintf(fp,"                           FALSE\n");
	fprintf(fp,"              A NC B = if B is a substring of A then\n");
	fprintf(fp,"                           FALSE\n");
	fprintf(fp,"                       else\n");
	fprintf(fp,"                           TRUE\n");
	fprintf(fp,"             \n");
	fprintf(fp,"             If A C B = TRUE, we say \"A contains B.\" \n");
	fprintf(fp,"             If A NC B = TRUE, we say \"A does not contain B.\" \n");
	fprintf(fp,"             Examples:\n");
	fprintf(fp,"                \"FRED WAS HERE\" C \"FRED\" = TRUE\n");
	fprintf(fp,"                \"FRED WAS HERE\" C \"WAS\" = TRUE\n");
	fprintf(fp,"                \"FRED WAS HERE\" C \"SALLY\" = FALSE \n");
	fprintf(fp,"                \"FRED WAS HERE\" NC \" WAS HERE\" = FALSE \n");
	fprintf(fp,"                \"FRED WAS HERE\" NC \" WAS THERE\" = TRUE \n");
	fprintf(fp,"    8. MOD       Modulo  	A MOD B  where A and B are numbers \n");
	fprintf(fp,"        %        Modulo         A % B  where A and B are numbers\n");
	fprintf(fp,"	Note: The A MOD B (or A % B) returns the remainder of A\n");
	fprintf(fp,"              divided by B.\n");
	fprintf(fp,"	Examples:\n");
	fprintf(fp,"		10 MOD 2 = 0\n");
	fprintf(fp,"		10 MOD 3 = 1\n");
	fprintf(fp,"		5 % 5 = 0\n");
	fprintf(fp,"		5 % 6 = 5\n");
	fprintf(fp,"III. GROUPERS\n");
	fprintf(fp,"     A. BOOLEAN Operators\n");
	fprintf(fp,"	The groupers OR, AND, and NOT are also called BOOLEAN\n");
	fprintf(fp,"        operators since they use BOOLEAN value expressions as\n");
	fprintf(fp,"        operands and yield BOOLEAN values.  The BOOLEAN values\n");
	fprintf(fp,"        are elements of the set bool which contains two values,\n");
	fprintf(fp,"        namely TRUE and FALSE (1 and 0), i.e., bool = {TRUE,FALSE}.  \n");
	fprintf(fp,"	\n");
	fprintf(fp,"        OR and AND are binary operators on the set bool, i.e.,\n");
	fprintf(fp,"        A OR B and A AND B are valid expressions where A and B have \n");
	fprintf(fp,"        BOOLEAN values (evaluate to either TRUE or FALSE). \n");
	fprintf(fp,"        NOT is a unary operator on the set bool, i.e.,\n");
	fprintf(fp,"        NOT A is valid where A has a BOOLEAN value. \n");
	fprintf(fp,"        The following Cayley Tables define the BOOLEAN operators\n");
	fprintf(fp,"        AND, OR, and NOT for all elements of bool = {TRUE,FALSE}.\n");
	fprintf(fp,"	  OR  | TRUE    FALSE		 AND  | TRUE    FALSE\n");
	fprintf(fp,"	------|-------|-------|		------|-------|-------|\n");
	fprintf(fp,"	TRUE  | TRUE  | TRUE  |		TRUE  | TRUE  | FALSE |\n");
	fprintf(fp,"	      |-------|-------|		      |-------|-------|\n");
	fprintf(fp,"	FALSE | TRUE  | FALSE |		FALSE | FALSE | FALSE |\n");
	fprintf(fp,"               ---------------                 ---------------\n");
	fprintf(fp,"		 NOT  |  TRUE   FALSE\n");
	fprintf(fp,"		------|-------|-------|\n");
	fprintf(fp,"       		      | FALSE | TRUE  |\n");
	fprintf(fp,"                       ---------------\n");
	fprintf(fp,"	Note: Parentheses should be used when using complex AND/OR/NOT\n");
	fprintf(fp,"              expressions to insured proper precedence of operations.\n");
	fprintf(fp," \n");
	fprintf(fp,"     B. IF THEN ELSE FI\n");
	fprintf(fp,"	General Rules:\n");
	fprintf(fp,"	1. An IF statement must always use a THEN, ELSE, and end\n");
	fprintf(fp,"           with a FI.\n");
	fprintf(fp,"	   Examples:\n");
	fprintf(fp,"             IF <expression> THEN RETURN_VALUE=<expression> FI\n");
	fprintf(fp,"             IF B < C THEN\n");
	fprintf(fp,"		IF C > 0 THEN RETURN_VALUE=C\n");
	fprintf(fp,"		ELSE RETURN_VALUE=B\n");
	fprintf(fp,"		FI\n");
	fprintf(fp,"             ELSE RETURN_VALUE=0\n");
	fprintf(fp,"             FI\n");
	fprintf(fp," 	\n");
	fprintf(fp,"	2. An IF statement must use the control RETURN_VALUE as\n");
	fprintf(fp,"           shown in the examples above.  RETURN_VALUE is assigned\n");
	fprintf(fp,"           a value by using '=' followed the value to return.\n");
	fprintf(fp,"           The RETURN_VALUE is the value of the IF THEN ELSE FI\n");
	fprintf(fp,"           statement (expression).\n");
	fprintf(fp,"IV. CONTROLS\n");
	fprintf(fp,"    Controls are special functions used by the expression parser.\n");
	fprintf(fp,"    A. BOOLEAN Constants\n");
	fprintf(fp,"       1. TRUE   -  BOOLEAN value implemented as the numeric value 1 \n");
	fprintf(fp,"       2. FALSE  -   BOOLEAN value implemented as the numeric value 0\n");
	fprintf(fp,"       Note: The above controls use no arguments and return 1 or 0	\n");
	fprintf(fp,"             representing the BOOLEAN values True and False,\n");
	fprintf(fp,"             respectively.\n");
	fprintf(fp,"    B. Binary String Functions - controls that take two string\n");
	fprintf(fp,"       arguments and return a string argument)\n");
	fprintf(fp,"       1. APPEND  -  Combines two strings as follows:\n");
	fprintf(fp,"	    <string 1> Append <string 2> = <string 1><string 2>\n");
	fprintf(fp,"          Example:  \"cat\" APPEND \"fish\" = \"catfish\"\n");
	fprintf(fp,"          	 \n");
	fprintf(fp,"    C. Unary String Functions - controls that take one string\n");
	fprintf(fp,"       argument and return a string argument)\n");
	fprintf(fp,"       1. STRING_TO_LOWER  -  Returns a copy of the value of\n");
	fprintf(fp,"          the string argument, with all upper case alphabetic\n");
	fprintf(fp,"          characters in the string converted to lower case,\n");
	fprintf(fp,"          leaving the remaining characters as they are.\n");
	fprintf(fp,"          Example: STRING_TO_LOWER(\"Hello, Joe!\") = \"hello, joe!\"\n");
	fprintf(fp,"       2. STRING_TO_UPPER  -  Returns a copy of the value of\n");
	fprintf(fp,"          the string argument, with all lower case alphabetic\n");
	fprintf(fp,"          characters in the string converted to upper case,\n");
	fprintf(fp,"          leaving the remaining characters as they are.\n");
	fprintf(fp,"          Example: STRING_TO_UPPER(\"Hello, Joe!\") = \"HELLO, JOE!\"\n");
	fprintf(fp,"    D. Evaluate Functions - controls that take expression arguments\n");
	fprintf(fp,"       in the form of strings and evaluates to appropriate type.\n");
	fprintf(fp,"       1. EVALUATE_BOOLEAN  -  Returns a BOOLEAN value (i.e. 1 or 0\n");
	fprintf(fp,"          representing True or False, respectively) evaluated\n");
	fprintf(fp,"          from the expression argument. \n");
	fprintf(fp,"          Example:\n");
	fprintf(fp,"           Let [A] = 7 and\n");
	fprintf(fp,"               [S] = \"IF [A]<5 THEN RETURN_VALUE=TRUE\n");
	fprintf(fp,"            		      ELSE RETURN_VALUE=FALSE FI\"\n");
	fprintf(fp,"           Then\n");
	fprintf(fp,"             EVALUATE_BOOLEAN([S])\n");
	fprintf(fp,"           = IF 7<5 THEN RETURN_VALUE=TRUE ELSE RETURN_VALUE=FALSE FI\n");
	fprintf(fp,"           = IF 0 THEN RETURN_VALUE=TRUE ELSE RETURN_VALUE=FALSE FI\n");
	fprintf(fp,"           = FALSE \n");
	fprintf(fp,"           = 0\n");
	fprintf(fp,"     \n");
	fprintf(fp,"          \n");
	fprintf(fp,"       2. EVALUATE_SHORT  -  Returns a Short Integer value\n");
	fprintf(fp,"          evaluated from the expression argument in the same\n");
	fprintf(fp,"          manner as illustrated in the example for\n");
	fprintf(fp,"          EVALUATE_BOOLEAN above. \n");
	fprintf(fp,"       \n");
	fprintf(fp,"       \n");
	fprintf(fp,"       3. EVALUATE_INTEGER  -  Returns a Long Integer value\n");
	fprintf(fp,"          evaluated from the expression argument in the same\n");
	fprintf(fp,"          manner as illustrated in the example for\n");
	fprintf(fp,"          EVALUATE_BOOLEAN above. \n");
	fprintf(fp,"       \n");
	fprintf(fp,"       3. EVALUATE_FLOAT  -  Returns a Float value\n");
	fprintf(fp,"          evaluated from the expression argument in the same\n");
	fprintf(fp,"          manner as illustrated in the example for\n");
	fprintf(fp,"          EVALUATE_BOOLEAN above. \n");
	fprintf(fp,"       4. EVALUATE_STRING  -  Returns a string value evaluated\n");
	fprintf(fp,"          from the expression argument in the same manner as\n");
	fprintf(fp,"          illustrated in the example for EVALUATE_BOOLEAN above. \n");
	fprintf(fp,"    E. Convert To String Functions - controls that take non-string\n");
	fprintf(fp,"       arguments and return string values\n");
	fprintf(fp,"       1. BOOLEAN_TO_STRING - Takes a BOOLEAN value and returns\n");
	fprintf(fp,"         \"1\" or \"0\" respectively.\n");
	fprintf(fp,"	 Note: Any non-zero number passed as an argument is\n");
	fprintf(fp,"               interpreted as True, i.e, 1. \n");
	fprintf(fp,"         Examples:\n");
	fprintf(fp,"           BOOLEAN_TO_STRING(TRUE) = \"1\"\n");
	fprintf(fp,"           BOOLEAN_TO_STRING(FALSE) = \"0\"\n");
	fprintf(fp,"           BOOLEAN_TO_STRING(0) = \"0\"\n");
	fprintf(fp,"           BOOLEAN_TO_STRING(1) = \"1\"\n");
	fprintf(fp,"           BOOLEAN_TO_STRING(-425) = \"1\"\n");
	fprintf(fp,"           BOOLEAN_TO_STRING([B] OR NOT [B]) = \"1\"\n");
	fprintf(fp,"           BOOLEAN_TO_STRING([B] AND NOT [B]) = \"0\"\n");
	fprintf(fp,"           \n");
	fprintf(fp,"       2. FLOAT_TO_STRING - Takes a Floating Decimal value and\n");
	fprintf(fp,"          returns a string representation of that value.\n");
	fprintf(fp,"          Example:  FLOAT_TO_STRING(001) = \"001\" \n");
	fprintf(fp,"       3. INTEGER_TO_STRING, SHORT_TO_STRING, and\n");
	fprintf(fp,"          DECIMAL_TO_STRING take one argument (a Long\n");
	fprintf(fp,"          Integer, a Short Integer, and a Decimal Value,\n");
	fprintf(fp,"          respectively) and return a string representation\n");
	fprintf(fp,"          of that value.\n");
	fprintf(fp,"    F. STRING_TO_DECIMAL -  Converts String to Decimal\n");
	fprintf(fp,"       Example: STRING_TO_DECIMAL(\"001.0000\") = 001.0000\n");
	fprintf(fp,"      \n");
	fprintf(fp,"    G. DATE_TO_VALUE -  Converts Date in the form MM-DD-YY where\n");
	fprintf(fp,"       MM represents the month, DD the day, and YY the year,\n");
	fprintf(fp,"       to seconds since \"01-01-70 00:00:00\" Greenwich Mean Time.\n");
	fprintf(fp,"    H. VALUE_TO_DATE -  Converts seconds to time in the form  \n");
	fprintf(fp,"       HH:MM:DD where HH is hours, MM is minutes, and DD is\n");
	fprintf(fp,"       seconds.\n");
	fprintf(fp,"    I. Round Functions - Functions that take decimal values\n");
	fprintf(fp,"       as arguments and return a whole number. \n");
	fprintf(fp,"       1. ROUND - Does normal rounding to the nearest whole. \n");
	fprintf(fp,"       Examples:\n");
	fprintf(fp,"          ROUND(1.25) = 1\n");
	fprintf(fp,"          ROUND(1.5) = 2\n");
	fprintf(fp,"       2. ROUNDUP - Rounds to the nearest whole number greater than\n");
	fprintf(fp,"          or equal to the argument.\n");
	fprintf(fp,"       Examples:\n");
	fprintf(fp,"          ROUNDUP(1.00) = 1 \n");
	fprintf(fp,"          ROUNDUP(1.01) = 2 \n");
	fprintf(fp,"          ROUNDUP(0.99) = 1 \n");
	fprintf(fp,"    J. RETURN_VALUE - used in following manner:\n");
	fprintf(fp,"       RETURN_VALUE = <expression>\n");
	fprintf(fp,"       RETURN_VALUE will return whatever value that the <expression>\n");
	fprintf(fp,"       is evaluated to when evaluating the expression containing\n");
	fprintf(fp,"       RETURN_VALUE. \n");
	fprintf(fp,"       Examples:\n");
	fprintf(fp,"         Expressions:\n");
	fprintf(fp,"           1. \"RETURN_VALUE=50\" - returns the integer 50 when evaluated\n");
	fprintf(fp,"           2. \"IF [A] > [B] THEN RETURN_VALUE=[A]\n");
	fprintf(fp,"               ELSE RETURN_VALUE=[B] FI\" - When this expression is\n");
	fprintf(fp,"               evaluated, it returns the maximum value of [A] and [B],\n");
	fprintf(fp,"               e.g., if [A] = 5 and [B] = 6, then the evaluation of the\n");
	fprintf(fp,"               above expression yields 6.\n");
	fprintf(fp,"           \n");
	fprintf(fp,"    K. SPELL -  Converts a number in cents to a string representing a\n");
	fprintf(fp,"                printed dollar amount as it would appear on a check. \n");
	fprintf(fp,"       Examples:\n");
	fprintf(fp,"         SPELL(12345) = \"One Hundred Twenty-Three And 45/100 Dollars\"\n");
	fprintf(fp,"         SPELL(146000) = \"One Thousand Four Hundred Sixty And 00/100 Dollars\"\n");
	fclose(fp);
}
static void SCRIPT_Xpert_Gui_ReadMe()
{
	FILE *fp=NULL;
	char *temp=NULL;

	temp=Rmalloc(RDAstrlen(CURRENTDIRECTORY)+RDAstrlen("Xpert.Gui.ReadMe")+15);
#ifdef WIN32
	sprintf(temp,"%s\\rda\\Xpert.Gui.ReadMe",CURRENTDIRECTORY);
#endif
#ifndef WIN32
	sprintf(temp,"%s/rda/Xpert.Gui.ReadMe",CURRENTDIRECTORY);
#endif
	unlink(temp);
	fp=fopen(temp,"w+b");
	if(temp!=NULL) Rfree(temp);

	fprintf(fp,"				SCREEN STANDARDS\n");
	fprintf(fp,"NOTE:  If specifications are too complicated, you may want to just look\n");
	fprintf(fp,"       at EXAMPLES.\n");
	fprintf(fp,"1.) RESOURCE LABELS - The majority of resource labels will be as follows:\n");
	fprintf(fp,"    For specification purposes, let fldtolabel be a funcion that converts \n");
	fprintf(fp,"    a field the following way:\n");
	fprintf(fp,"    For field name A then fldtolabel(A) converts the first letter in each \n");
	fprintf(fp,"    \"word\" of A to uppercase and converts the remaining letters to lowercase.\n");
	fprintf(fp,"    For example, fldtolabel(\"FRED WAS HERE\") = \"Fred Was Here\".\n");
	fprintf(fp,"    Let tolower(A) convert all letters of A to lowercase.  For example,\n");
	fprintf(fp,"    tolower(\"ACCOUNT CODE\") = \"account code\".\n");
	fprintf(fp,"    Let ++ stand for concatenation.  Example: \"cat\" ++ \"bird\" = \"catbird\".\n");
	fprintf(fp,"    FOR ALL field names A, B, and C then \n");
	fprintf(fp,"	RESOURCE                   LABEL \n");
	fprintf(fp,"	--------                   -----\n");
	fprintf(fp,"     a.)   A                       fldtolabel(A)\n");
	fprintf(fp,"     b.)  [A]                      fldtolabel(A)\n");
	fprintf(fp,"			    \n");
	fprintf(fp,"     c.) [A][B]                    fldtolabel(B)\n");
	fprintf(fp,"     d.) [A][B][C]                 fldtolabel(C)\n");
	fprintf(fp,"     e.) RANGE ON [A][B]           \"Range on \" ++ fldtolabel(B)\n");
	fprintf(fp,"     f.) FROM [A][B]               \"From \" ++ fldtolabel(B)\n");
	fprintf(fp,"     g.) TO [A][B]                 \"To \" ++ fldtolabel(B)\n");
	fprintf(fp,"			       \n");
	fprintf(fp,"     h.) SELECT [A][B] FALSE       If B = \"DELETEFLAG\" Then\n");
	fprintf(fp,"				      \"Select non-deleted records\"\n");
	fprintf(fp,"				   Else\n");
	fprintf(fp,"				      \"Select non-\" ++ tolower(B) ++ \" records\"    \n");
	fprintf(fp,"     i.) SELECT [A][B] TRUE        If B = \"DELETEFLAG\" Then\n");
	fprintf(fp,"				      \"Select deleted records\"\n");
	fprintf(fp,"				   Else\n");
	fprintf(fp,"				      \"Select \" ++ tolower(B) ++ \" records\"\n");
	fprintf(fp,"	EXAMPLES\n");
	fprintf(fp,"	--------\n");
	fprintf(fp,"     a.) ACCOUNT CODE  ----->  Account Code \n");
	fprintf(fp,"     b.) [ACCOUNT CODE]  ----->  Account Code \n");
	fprintf(fp,"     c.) [FINEACC][[ACCOUNT CODE]  ----->  Account Code \n");
	fprintf(fp,"     d.) [FINMGT][FINEACC][[ACCOUNT CODE]  ----->  Account Code \n");
	fprintf(fp,"     e.) RANGE ON [FINEACC][[ACCOUNT CODE]  ----->  Range on Account Code \n");
	fprintf(fp,"     f.) FROM [FINEACC][[ACCOUNT CODE]  ----->  From Account Code \n");
	fprintf(fp,"     g.) TO [FINEACC][[ACCOUNT CODE]  ----->  To Account Code \n");
	fprintf(fp,"     h.) SELECT [FINBYR][DELETEFLAG] FALSE  ----->  Select non-deleted records\n");
	fprintf(fp,"	 SELECT [FINBACT][POSTED] FALSE  ----->  Select non-posted records\n");
	fprintf(fp,"     i.) SELECT [FINBYR][DELETEFLAG] TRUE  ----->  Select deleted records\n");
	fprintf(fp,"	 SELECT [FINBACT][POSTED] TRUE  ----->  Select posted records\n");
	fprintf(fp,"   Some exceptions are\n");
	fprintf(fp,"	QUIT buttons get the label \"Cancel\".\n");
	fprintf(fp,"	Some screens with supporting resources such as [FINEACC][DESCRIPTION] \n");
	fprintf(fp,"	and [FINYEAR][DESCRIPTION] on the same screen, by the above \n");
	fprintf(fp,"	specification, would both get the label \"Description\".  In this case,\n");
	fprintf(fp,"	we'll make the first label \"Account Description\" and the second\n");
	fprintf(fp,"	\"Fiscal Year Description\".\n");
	fprintf(fp,"	The labels for DELETEFLAG fields will be \"Delete this record\".  These\n");
	fprintf(fp,"	appear on the Maintain Screen.\n");
	fprintf(fp,"	Other exceptions may be made in making a label clearer to the user\n");
	fprintf(fp,"	as to what the resource is for. \n");
	fprintf(fp,"2.) MAINTAIN SCREEN - General Standards.  Exceptions can be made for some\n");
	fprintf(fp,"    screens to make them look better.\n");
	fprintf(fp,"    \n");
	fprintf(fp,"    a.) When a scrolled list is by itself on a line, it should be followed\n");
	fprintf(fp,"	by an empty label.  Sometimes two or more scrolled lists need to be\n");
	fprintf(fp,"	followed by an empty label, depending on how it looks.\n");
	fprintf(fp,"    b.) Key Resources with supporting field standard resources should be on\n");
	fprintf(fp,"	one line with supporting resource in a box attached to the end of the\n");
	fprintf(fp,"	screen.\n");
	fprintf(fp,"    c.) For dates and times following a toggle button (other than ENTRY DATE\n");
	fprintf(fp,"	and ENTRY TIME) use the following example:\n");
	fprintf(fp,"	With [FINEACT][POSTED], [FINEACT][POSTED BY], [FINEACT][POSTED DATE],\n");
	fprintf(fp,"	[FINEACT][POSTED TIME] use\n");
	fprintf(fp,"	[] Posted  By:[               ]   Date:[         ]  Time:[        ]\n");
	fprintf(fp,"	where the brackets represent the appropriate resource.\n");
	fprintf(fp,"    d.) Buttons on the bottom of the screen should appear as follows\n");
	fprintf(fp,"	[    Browse     ] [ Save Defaults ] [ Fast Save ]\n");
	fprintf(fp,"	[     Save      ] [     Cancel    ] [    Help   ]\n");
	fprintf(fp,"	Notice:  SAVE NO UPDATE resource has label \"Fast Save\".\n");
	fprintf(fp,"	One or two function buttons can be inserted between Browse and\n");
	fprintf(fp,"	Save Defaults.  If more than two additional function buttons,\n");
	fprintf(fp,"	place these on a line above those shown here.\n");
	fprintf(fp,"	Put a Horizontal Single Line seperator on line above the first\n");
	fprintf(fp,"	line of buttons.  Put a box around the each line of buttons.  \n");
	fprintf(fp,"	FOR ALL consecutive lines of buttons A and B then put a\n");
	fprintf(fp,"	Horizontal Double Line separator between A and B.\n");
	fprintf(fp,"	EXAMPLE:\n");
	fprintf(fp,"		New Line\n");
	fprintf(fp,"		Seperator  Resource Type: Horizontal Single Line\n");
	fprintf(fp,"		End Line\n");
	fprintf(fp,"		New Line\n");
	fprintf(fp,"		New Box\n");
	fprintf(fp,"		New Line	\n");
	fprintf(fp,"		<button 1>\n");
	fprintf(fp,"		<button 2>\n");
	fprintf(fp,"		<button 3>\n");
	fprintf(fp,"		End Line\n");
	fprintf(fp,"		End Box\n");
	fprintf(fp,"		End Line\n");
	fprintf(fp,"		New Line\n");
	fprintf(fp,"		Seperator  Resource Type: Horizontal Double Line\n");
	fprintf(fp,"		End Line\n");
	fprintf(fp,"		New Line\n");
	fprintf(fp,"		New Box\n");
	fprintf(fp,"		New Line\n");
	fprintf(fp,"		<button 4>\n");
	fprintf(fp,"		<button 5>\n");
	fprintf(fp,"		<button 6>\n");
	fprintf(fp,"		End Line\n");
	fprintf(fp,"		End Box\n");
	fprintf(fp,"		End Line\n");
	fprintf(fp,"		New Line\n");
	fprintf(fp,"		Seperator  Resource Type: Horizontal Double Line\n");
	fprintf(fp,"		End Line\n");
	fprintf(fp,"		New Line\n");
	fprintf(fp,"		New Box\n");
	fprintf(fp,"		New Line\n");
	fprintf(fp,"		<button 7>\n");
	fprintf(fp,"		<button 8>\n");
	fprintf(fp,"		<button 9>\n");
	fprintf(fp,"		End Line\n");
	fprintf(fp,"		End Box\n");
	fprintf(fp,"		End Line\n");
	fprintf(fp,"     e.) Always put key resources in the same order as the #1 key in         \n");
	fprintf(fp,"	 the file definition.\n");
	fprintf(fp,"3.) BROWSE SCREEN\n");
	fprintf(fp,"    a.) If RUN FUNCTION is used it should be the first resource shown on\n");
	fprintf(fp,"	the screen.  It should be followed on the same line by an empty\n");
	fprintf(fp,"        label.\n");
	fprintf(fp,"    b.) Key Resources with supporting field standard resources should be on\n");
	fprintf(fp,"	one line with supporing resource in a box attached to the end of the\n");
	fprintf(fp,"	screen.\n");
	fprintf(fp,"	\n");
	fprintf(fp,"    c.) Always put key resources in the same order as the #1 key in         \n");
	fprintf(fp,"	the file definition.\n");
	fprintf(fp,"    \n");
	fprintf(fp,"    d.) [ Define List ] [ Search ] - these button resoures should be below\n");
	fprintf(fp,"	the key resources.  Following these on the same line should be an\n");
	fprintf(fp,"	empty label.  The line should be in a box.\n");
	fprintf(fp,"    e.) Following the preceding buttons on a new line should be the SEARCH\n");
	fprintf(fp,"	FIELD resource surrounded by a box.\n");
	fprintf(fp,"    f.)  BROWSE LIST should be 10 rows.\n");
	fprintf(fp,"    g.)  Buttons on the bottom of the screen should appear as follows:\n");
	fprintf(fp,"		[  Add  ] [ Select ] [ Cancel ] [ Help ]\n");
	fprintf(fp,"	Surround this line of buttons by a box:\n");
	fprintf(fp,"		<new line> <new box> <new line>\n");
	fprintf(fp,"		<button sequence>\n");
	fprintf(fp,"		<end line> <end box> <end line>\n");
	fprintf(fp," 4. DEFINE LIST\n");
	fprintf(fp,"     a.) Remove KEY LIST resource.  This can no longer be set here, is\n");
	fprintf(fp,"	 determine by *.MTN.\n");
	fprintf(fp,"     b.) Should start with the label \n");
	fprintf(fp,"	 \"Enter the position and length for the following fields:\"\n");
	fprintf(fp,"     c.) Next, the labels, POSITION resources, and LENGTH resources\n");
	fprintf(fp,"	 should be done like the following example (indented for\n");
	fprintf(fp,"         readability):\n");
	fprintf(fp,"	 New Line\n");
	fprintf(fp,"	   New Box\n");
	fprintf(fp,"	     New Line\n");
	fprintf(fp,"	       [Label] Label: [Deleteflag:]\n");
	fprintf(fp,"	       New Box\n");
	fprintf(fp,"	         New Line\n");
	fprintf(fp,"	           [Standard Resource] Name: [DELETEFLAG POSITION]\n");
	fprintf(fp,"	           [Standard Resource] Name: [DELETEFLAG LENGTH]\n");
	fprintf(fp,"                 End Line\n");
	fprintf(fp,"               End Box\n");
	fprintf(fp,"	       [Label] Label: [Definition Type:]\n");
	fprintf(fp,"	       New Box\n");
	fprintf(fp,"	         New Line\n");
	fprintf(fp,"	           [Standard Resource] Name: [DEFINITION TYPE POSITION]\n");
	fprintf(fp,"	           [Standard Resource] Name: [DEFINITION TYPE LENGTH]\n");
	fprintf(fp,"	         End Line\n");
	fprintf(fp,"               End Box\n");
	fprintf(fp,"	     End Line\n");
	fprintf(fp,"	     New Line\n");
	fprintf(fp,"	       [Label] Label: [Account Code:]\n");
	fprintf(fp,"	       New Box\n");
	fprintf(fp,"	         New Line\n");
	fprintf(fp,"	           [Standard Resource] Name: [ACCOUNT CODE POSITION]\n");
	fprintf(fp,"	           [Standard Resource] Name: [ACCOUNT CODE LENGTH]\n");
	fprintf(fp,"	         End Line\n");
	fprintf(fp,"               End Box\n");
	fprintf(fp,"	       [Label] Label: [Fiscal Year:]\n");
	fprintf(fp,"	       New Box\n");
	fprintf(fp,"	         New Line\n");
	fprintf(fp,"	           [Standard Resource] Name: [FISCAL YEAR POSITION]\n");
	fprintf(fp,"	           [Standard Resource] Name: [FISCAL YEAR LENGTH]\n");
	fprintf(fp,"	          End Line\n");
	fprintf(fp,"               End Box\n");
	fprintf(fp,"	     End Line\n");
	fprintf(fp,"	   End Box\n");
	fprintf(fp,"	 End Line\n");
	fprintf(fp,"	 \n");
	fprintf(fp,"	 An alternative, if it looks better in some screens,\n");
	fprintf(fp,"	 is the following:\n");
	fprintf(fp,"	 New Line\n");
	fprintf(fp,"	   New Box\n");
	fprintf(fp,"	     New Line\n");
	fprintf(fp,"	       [Label] Label: [Deleteflag:]\n");
	fprintf(fp,"	       New Box\n");
	fprintf(fp,"	         New Line\n");
	fprintf(fp,"	           [Standard Resource] Name: [DELETEFLAG POSITION]\n");
	fprintf(fp,"	           [Standard Resource] Name: [DELETEFLAG LENGTH]\n");
	fprintf(fp,"	         End Line\n");
	fprintf(fp,"	       End Box\n");
	fprintf(fp,"	     End Line\n");
	fprintf(fp,"	     New Line\n");
	fprintf(fp,"	       [Label] Label: [Definition Type:]\n");
	fprintf(fp,"	       New Box\n");
	fprintf(fp,"	         New Line\n");
	fprintf(fp,"	           [Standard Resource] Name: [DEFINITION TYPE POSITION]\n");
	fprintf(fp,"	           [Standard Resource] Name: [DEFINITION TYPE LENGTH]\n");
	fprintf(fp,"	         End Line\n");
	fprintf(fp,"	       End Box\n");
	fprintf(fp,"	     End Line\n");
	fprintf(fp,"	     New Line\n");
	fprintf(fp,"	       [Label] Label: [Account Code:]\n");
	fprintf(fp,"	       New Box\n");
	fprintf(fp,"	         New Line\n");
	fprintf(fp,"	           [Standard Resource] Name: [ACCOUNT CODE POSITION]\n");
	fprintf(fp,"	           [Standard Resource] Name: [ACCOUNT CODE LENGTH]\n");
	fprintf(fp,"	         End Line\n");
	fprintf(fp,"	       End Box\n");
	fprintf(fp,"	     End Line\n");
	fprintf(fp,"	     New Line\n");
	fprintf(fp,"	       [Label] Label: [Fiscal Year:]\n");
	fprintf(fp,"	       New Box\n");
	fprintf(fp,"	         New Line\n");
	fprintf(fp,"	           [Standard Resource] Name: [FISCAL YEAR POSITION]\n");
	fprintf(fp,"	           [Standard Resource] Name: [FISCAL YEAR LENGTH]\n");
	fprintf(fp,"                 End Line\n");
	fprintf(fp,"               End Box\n");
	fprintf(fp,"	     End Line\n");
	fprintf(fp,"	   End Box\n");
	fprintf(fp,"	 End Line\n");
	fprintf(fp,"     d.) The buttons should be at the bottom of the screen in a box\n");
	fprintf(fp,"	 in the following order:\n");
	fprintf(fp,"	 [ Save Defaults ] [   Select   ] [   Cancel   ] [   Help   ]\n");
	fprintf(fp,"	 Notice: Label for DEFAULTS is \"Save Defaults\".\n");
	fprintf(fp,"         Surround this line of buttons by a box:\n");
	fprintf(fp,"		<new line> <new box> <new line>\n");
	fprintf(fp,"		<button sequence>\n");
	fprintf(fp,"		<end line> <end box> <end line>\n");
	fprintf(fp,"     e.) Set number of columns to 3 for POSITION and LENGTH resources.\n");
	fprintf(fp,"5.) SEARCH BROWSE\n");
	fprintf(fp,"    a.) Make the Range, To, From widgets like the example below:\n");
	fprintf(fp,"	New Line\n");
	fprintf(fp,"	[Toggle Button (Boolean) Name: [FINBYR][FISCAL YEAR] Label:\n");
	fprintf(fp,"						       [Range on Fiscal Year]\n");
	fprintf(fp,"	[Label] Label: [From:]\n");
	fprintf(fp,"	[Standard Resource] Name: [FROM [FINBYR][FISCAL YEAR]] Label:\n");
	fprintf(fp,"						       [To Fiscal Year]\n");
	fprintf(fp,"	[Label] Label: [To:]\n");
	fprintf(fp,"	[Standard Resource] Name: [TO [FINBYR][FISCAL YEAR]] Label:\n");
	fprintf(fp,"						       [From Fiscal Year]\n");
	fprintf(fp,"	End Line\n");
	fprintf(fp,"    b.) For SELECT [A][B] TRUE/FALSE resources, always put FALSE one first.\n");
	fprintf(fp,"	If there's more than one pair of these then put a box around\n");
	fprintf(fp,"	all of these SELECT [A][B] * resources (not the individual pairs\n");
	fprintf(fp,"	but over the whole set of resources).\n");
	fprintf(fp,"	EXAMPLE\n");
	fprintf(fp,"		New Line\n");
	fprintf(fp,"		New Box\n");
	fprintf(fp,"		New Line\n");
	fprintf(fp,"		...  SELECT ... FALSE ...\n");
	fprintf(fp,"		...  SELECT ... TRUE ...\n");
	fprintf(fp,"		End Line\n");
	fprintf(fp,"		New Line\n");
	fprintf(fp,"		...  SELECT ... FALSE ...\n");
	fprintf(fp,"		...  SELECT ... TRUE ...\n");
	fprintf(fp,"		End Line\n");
	fprintf(fp,"		End Box\n");
	fprintf(fp,"		End Line\n");
	fprintf(fp,"    c.) Buttons - Same as DEFINE LIST\n");
	fclose(fp);
}
static void SCRIPT_Xpert_Read_Me()
{
	FILE *fp=NULL;
	char *temp=NULL;

	temp=Rmalloc(RDAstrlen(CURRENTDIRECTORY)+RDAstrlen("Xpert.Read.Me")+15);
#ifdef WIN32
	sprintf(temp,"%s\\rda\\Xpert.Read.Me",CURRENTDIRECTORY);
#endif
#ifndef WIN32
	sprintf(temp,"%s/rda/Xpert.Read.Me",CURRENTDIRECTORY);
#endif
	unlink(temp);
	fp=fopen(temp,"w+b");
	if(temp!=NULL) Rfree(temp);

	fprintf(fp,"/* Xpert.Read.Me - Xpert's Runtime Diagnostics */\n");
	fprintf(fp,"	There is a special environment variable \"RDADIAG\", which is used to\n");
	fprintf(fp,"initialize Runtime Diagnostics throughout the Xpert System.  These are used\n");
	fprintf(fp,"to analize where problems may be.  Since everything throughout Xpert is\n");
	fprintf(fp,"dynamically created, everyone's possible situations are different, the \n");
	fprintf(fp,"only way to determine if it is a program bug, and not a configuration\n");
	fprintf(fp,"problem is to have Runtime Diagnostics.\n");
	fprintf(fp,"	The following is a list of available Runtime Diagnostics Levels.  They\n");
	fprintf(fp,"may be used singularly or in any combination.\n");
	fprintf(fp,"	APPLICATION - Application diagnostics report on selection criteria of a\n");
	fprintf(fp," 		      particular program, like Select Payroll, or Make Transactions.\n");
	fprintf(fp,"	RPTGEN	- RPTGEN Diagnostics report diagnostics from the Report Generator\n");
	fprintf(fp,"		  library from every step of the report process.\n");
	fprintf(fp,"	FIELD_RPTGEN - RPTGEN Diagnostics for use in the field.  This is a slimmed \n");
	fprintf(fp,"		  down version of RPTGEN diagnostics.\n");
	fprintf(fp,"	RPTGEN_SELECT - RPTGEN Diagnostics for only the select records portion of\n");
	fprintf(fp,"		  the report.\n");
	fprintf(fp,"	RPTGEN_SLTALL - RPTGEN Diagnostics RPTGEN and EVAL diagnostics for the \n");
	fprintf(fp,"		  first half of the report.  This includes selecting records, creating\n");
	fprintf(fp,"		  the sort file, etc.\n");
	fprintf(fp,"	RPTGEN_SLTEVAL - RPTGEN Diagnostics for report EVAL Diagnostics for \n");
	fprintf(fp,"		  expressions computed in the Select Records portion of the report.\n");
	fprintf(fp,"	RPTGEN_SLTREC - RPTGEN Diagnostics for select record status.  This is good\n");
	fprintf(fp,"		  for when records aren't being selected on a report.\n");
	fprintf(fp,"	RPTGEN_OUTPUT - RPTGEN Diagnostics for the output side of the report.\n");
	fprintf(fp,"	RPTGEN_OUTALL - RPTGEN Diagnostics for receiving RPTGEN and EVAL \n");
	fprintf(fp,"		  diagnostics at the Output side of the report.\n");
	fprintf(fp,"	RPTGEN_OUTEXP - EVAL Diagnostics for the output side of the report.\n");
	fprintf(fp,"	RPTGEN_OUTLINE - EVAL Diagnostics for the expressions on a line of a \n");
	fprintf(fp,"		  report only.\n");
	fprintf(fp,"	ALLOC	- Memory Allocation Diagnostics. Since everything in the system\n");
	fprintf(fp,"		  is dynamically created the memory space for the 90%% of \n");
	fprintf(fp,"		  variables are allocated with an malloc, realloc, or calloc.\n");
	fprintf(fp,"		  Upon completion they are Free'd. This Runtime level \n");
	fprintf(fp,"		  checks the status of memory and checks for corruption.\n");
	fprintf(fp,"	GUI	- GUI Diagnostics reports everything used to create custom \n");
	fprintf(fp,"		  screens, each resource as it's created, updated, etc.  \n");
	fprintf(fp,"	FIELD_GUI - GUI Diagnostics for use in the field.  These are slimmed down\n");
	fprintf(fp,"		  version of GUI Diagnostics.\n");
	fprintf(fp,"	NRD 	- NRD Diagnostics reports everything used to manage the Xpert\n");
	fprintf(fp,"		  Database Engine from the creation of files, updating fields,\n");
	fprintf(fp,"		  writing files, reading records, file movements, etc.\n");
	fprintf(fp,"	FIELD_NRD - NRD Diagnostics for use in the field.  These are slimmed down \n");
	fprintf(fp,"		  versions of NRD Diagnostics.\n");
	fprintf(fp,"	RDADTA	- RDADTA Diagnostics reports diagnostics particular to the \n");
	fprintf(fp,"		  RDA Database Engine.\n");
	fprintf(fp,"	VF	- VF Diagnostics reports diagnostics particular to Variable Length\n");
	fprintf(fp,"		  files.  This is used primarily by the RDA Database Engine.\n");
	fprintf(fp,"	RF	- RF Diagnostics reports diagnostics particular to Raw Files.\n");
	fprintf(fp,"		  These functions are used primarily by Variable Length Files\n");
	fprintf(fp,"		  and the RDA Database Engine.\n");
	fprintf(fp,"	EVAL	- EVAL Diagnostics are used to report from the Expression Parsing\n");
	fprintf(fp,"		  routines.  These are used in GUI, MIX, VIRTUAL, and RPTGEN \n");
	fprintf(fp,"		  primarily.  Though expressions may be also be local to an\n");
	fprintf(fp,"		  application program, i.e. Set Check Numbers in Vendor Payments.\n");
	fprintf(fp,"	FIELD_EVAL - EVAL Diagnostics for use in the field.  These are slimmed\n");
	fprintf(fp,"		  down versions of EVAL.\n");
	fprintf(fp,"	SEC	- SEC Diagnostics are used to report on Security Functions.  This\n");
	fprintf(fp,"		  is a good test to run when confronted with security problems.\n");
	fprintf(fp,"		  It will report when access is granted/denied and at which\n");
	fprintf(fp,"		  stage of the process this was determined.\n");
	fprintf(fp,"	FIELD_SEC - SEC Diagnostics for use in the field.  This is a slimmed down\n");
	fprintf(fp,"		  version of SEC Diagnostics.\n");
	fprintf(fp,"	TRANS	- TRANS Diagnostics are used to report on Transaction Processing\n");
	fprintf(fp,"		  functions.  \n");
	fprintf(fp,"	OLH	- OLH Diagnostics are used to report on On-Line Help functions.\n");
	fprintf(fp,"		  If you are customizing a considerable amount of screens, \n");
	fprintf(fp,"		  creating optional screens, etc. and help isn't found.  If\n");
	fprintf(fp,"		  from looking in Define Help, you are still confused, turn\n");
	fprintf(fp,"		  this on.  It will report on each step of the help process\n");
	fprintf(fp,"		  allowing you to determine the problem.\n");
	fprintf(fp,"	FIELD_OLH - OLH Diagnostics for use in the field.  This is a slimmed down\n");
	fprintf(fp,"		  version of On-Line Help Diagnostics.\n");
	fprintf(fp,"	MIX	- MIX Diagnostics are used to report on Mix functions. These\n");
	fprintf(fp,"		  functions are used as conveniences since they can merge \n");
	fprintf(fp,"		  things from multiple libraries below.  A good example of a\n");
	fprintf(fp,"		  mix function is the Browse Functions. It combines GUI, OLH,\n");
	fprintf(fp,"		  SEC, TRANS, and NRD functions and well as everything below it.\n");
	fprintf(fp,"	FIELD_MIX - MIX Diagnostics for use in the field.  This is a slimmed \n");
	fprintf(fp,"		  down version of MIX Diagnostics.\n");
	fprintf(fp,"	BIN	- BIN Diagnostics are used to report on creating Binaries. This\n");
	fprintf(fp,"		  is important if you are discovering corrupted binary files.\n");
	fprintf(fp,"		  Note: many times binary's are in Binary Libraries, you may \n");
	fprintf(fp,"		  want both diagnostic levels.\n");
	fprintf(fp,"	BINLIB	- BINLIB Diagnostics are used to report on creating and working\n");
	fprintf(fp,"		  with Binary Libraries.  Note: many times this is used in \n");
	fprintf(fp,"		  conjunction with BIN.\n");
	fprintf(fp,"	IMPORT	- IMPORT Diagnostics are used to report on the functions used\n");
	fprintf(fp,"		  when importing and exporting data from Xpert.  It will allow \n");
	fprintf(fp,"		  you to see the values of fields as they are stripped from \n");
	fprintf(fp,"		  text files, and steps used in the import/export process.\n");
	fprintf(fp,"	FIELD_IMPORT - IMPORT Diagnostics for use in the field.  Slimmed down \n");
	fprintf(fp,"		  version of IMPORT.\n");
	fprintf(fp,"	VIRTUAL	- VIRTUAL Diagnostics are used to report on the functions used\n");
	fprintf(fp,"		  to create, manage, and process virtual fields.  This doesn't\n");
	fprintf(fp,"		  include the Expression Parsing (see EVAL).  These are good\n");
	fprintf(fp,"		  to use when a virtual field isn't being found, not displayed,\n");
	fprintf(fp,"		  etc.  When one isn't computing properly, EVAL would be \n");
	fprintf(fp,"		  required to determine problem.\n");
	fprintf(fp,"	FIELD_VIRTUAL - Virtual Diagnostics for use in the field.  Slimmed down\n");
	fprintf(fp,"		  version of VIRTUAL diagnostics.\n");
	fprintf(fp,"	EXEPROG	- EXEPROG Diagnostics are used to report on calls to execute other\n");
	fprintf(fp,"		  programs.  This is good for displaying the system error's \n");
	fprintf(fp,"		  when a program is having trouble executing another program.\n");
	fprintf(fp,"	MISC	- MISC Diagnostics are few and low level.  MISC functions are\n");
	fprintf(fp,"		  small miscellanous functions used by all levels of libraries\n");
	fprintf(fp,"		  and applications.  These are parts each share. This is used\n");
	fprintf(fp,"		  to reduce repetition and still maintain clean breaks in the \n");
	fprintf(fp,"		  the libraries.\n");
	fprintf(fp,"	Each of the Diagnostic levels will report messages in the following format:\n");
	fprintf(fp,"		\n");
	fprintf(fp,"		DIAG	- Will proceed all Diagnostic messages reported via the \n");
	fprintf(fp,"			  environment variable.\n");
	fprintf(fp,"		Errors 	- Will proceed all Messages pertaining to an Error.  These\n");
	fprintf(fp,"			  will be reported whether a diagnostic is activated or not.\n");
	fprintf(fp,"		TRACE	- A Trace statement viewed in diagnostics is hard coded, and\n");
	fprintf(fp,"			  used by Development to record a time and date stamp at a\n");
	fprintf(fp,"			  specific line of a program.  Generally it is proceeded by\n");
	fprintf(fp,"			  some data or variable status printed as well.  These are\n");
	fprintf(fp,"			  intended to be removed prior to being released by \n");
	fprintf(fp,"			  Development.\n");
	fprintf(fp,"	Hopefully these Diagnostics may be used in helping Support and \n");
	fprintf(fp,"Sales/Marketing with installations and support of clients. \n");
	fclose(fp);
}
void README()
{
	SCRIPT_Xpert_Evaluate_ReadMe();
	SCRIPT_Xpert_Gui_ReadMe();
	SCRIPT_Xpert_Read_Me();
}
